<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Geofence Tracker</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f0f9ff;
      padding: 20px;
      text-align: center;
    }
    .container {
      max-width: 500px;
      margin: auto;
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    h2 {
      margin-top: 0;
    }
    button {
      padding: 10px 15px;
      margin: 10px 5px;
      border: none;
      border-radius: 6px;
      background: #0077cc;
      color: white;
      cursor: pointer;
    }
    button.clear {
      background-color: #cc0000;
    }
    .status {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }
    .revisited { color: green; }
    .new { color: red; }
    ul { text-align: left; padding-left: 20px; }
    .accuracy {
      font-size: 14px;
      color: #666;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üìç Circular Geofence Tracker</h2>
    <p id="locationInfo">Waiting for location...</p>
    <p id="accuracyInfo" class="accuracy"></p>
    <div id="status" class="status">Status: --</div>

    <button onclick="markZone()">‚ûï Mark Current Location</button>
    <button class="clear" onclick="clearZones()">üóë Clear Zones</button>

    <h3>üìå Saved Zones:</h3>
    <ul id="zoneList"></ul>
  </div>

  <script>
    const radiusThresholdMeters = 3;
    const movementThreshold = 1; // Minimum movement to consider (in meters)
    const maxAllowedAccuracy = 15; // Discard if accuracy worse than 15 meters

    let currentPosition = null;
    let lastKnownPosition = null;

    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = angle => angle * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function updateLocation() {
      if (!navigator.geolocation) {
        alert("Geolocation not supported!");
        return;
      }

      navigator.geolocation.watchPosition(
        position => {
          const { latitude, longitude, accuracy } = position.coords;

          // Skip noisy GPS
          if (accuracy > maxAllowedAccuracy) {
            document.getElementById("accuracyInfo").innerText = `‚ö†Ô∏è Low GPS accuracy: ¬±${accuracy.toFixed(1)}m (ignoring)`;
            return;
          }

          const newPosition = { lat: latitude, lon: longitude };

          // Skip minor movement
          if (lastKnownPosition) {
            const moved = haversine(
              lastKnownPosition.lat, lastKnownPosition.lon,
              newPosition.lat, newPosition.lon
            );
            if (moved < movementThreshold) {
              document.getElementById("accuracyInfo").innerText = `üìç No significant movement (Œî${moved.toFixed(2)}m)`;
              return;
            }
          }

          currentPosition = newPosition;
          lastKnownPosition = newPosition;

          document.getElementById("locationInfo").innerHTML =
            `Lat: ${latitude.toFixed(6)}<br>Lon: ${longitude.toFixed(6)}`;
          document.getElementById("accuracyInfo").innerText =
            `üì° Accuracy: ¬±${accuracy.toFixed(1)} meters`;

          checkZones();
        },
        error => {
          document.getElementById("status").innerText = "Unable to access GPS.";
        },
        { enableHighAccuracy: true, maximumAge: 1000 }
      );
    }

    function markZone() {
      if (!currentPosition) {
        alert("Waiting for GPS fix...");
        return;
      }
      const zones = JSON.parse(localStorage.getItem("geoZones") || "[]");
      zones.push({
        lat: currentPosition.lat,
        lon: currentPosition.lon,
        time: new Date().toLocaleString()
      });
      localStorage.setItem("geoZones", JSON.stringify(zones));
      displayZones();
    }

    function displayZones() {
      const zones = JSON.parse(localStorage.getItem("geoZones") || "[]");
      const list = document.getElementById("zoneList");
      if (zones.length === 0) {
        list.innerHTML = "<li>No zones saved.</li>";
        return;
      }

      list.innerHTML = zones.map((z, i) =>
        `<li>#${i+1}: ${z.lat.toFixed(6)}, ${z.lon.toFixed(6)} <br>üïí ${z.time}</li>`
      ).join("");
    }

    function clearZones() {
      if (confirm("Clear all saved zones?")) {
        localStorage.removeItem("geoZones");
        displayZones();
        document.getElementById("status").innerText = "Status: --";
      }
    }

    function checkZones() {
      const zones = JSON.parse(localStorage.getItem("geoZones") || "[]");
      if (!currentPosition || zones.length === 0) {
        document.getElementById("status").innerText = "Status: No zones.";
        return;
      }

      let revisited = zones.some(zone => {
        const dist = haversine(currentPosition.lat, currentPosition.lon, zone.lat, zone.lon);
        return dist <= radiusThresholdMeters;
      });

      document.getElementById("status").innerHTML = revisited
        ? `<span class="revisited">‚úÖ Revisited</span>`
        : `<span class="new">üÜï New Location</span>`;
    }

    // Init
    updateLocation();
    displayZones();
  </script>
</body>
</html>
