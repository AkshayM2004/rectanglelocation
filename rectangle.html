<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Live Revisit Tracker</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0; padding: 0;
      background: #e8f7ff;
      display: flex; flex-direction: column; align-items: center;
    }
    .container {
      padding: 20px;
      width: 100%; max-width: 600px;
    }
    canvas {
      border: 1px solid #ccc;
      width: 100%;
      height: 300px;
      background: #fff;
    }
    button {
      margin: 5px; padding: 10px 15px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
    }
    button.set { background-color: #007bff; color: white; }
    button.clear { background-color: #dc3545; color: white; }
    #status {
      font-size: 18px;
      margin-top: 10px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üìç Live Rectangle Revisit Tracker</h2>
    <canvas id="mapCanvas" width="400" height="300"></canvas>
    <div>
      <button class="set" onclick="setPoint(1)">Set Point 1</button>
      <button class="set" onclick="setPoint(2)">Set Point 2</button>
      <button class="clear" onclick="clearData()">Clear</button>
    </div>
    <div id="status">Waiting for GPS...</div>
  </div>

  <script>
    let point1 = null, point2 = null, currentPos = null;
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');

    function savePoints() {
      localStorage.setItem('rectanglePoints', JSON.stringify({ point1, point2 }));
    }

    function loadPoints() {
      const saved = localStorage.getItem('rectanglePoints');
      if (saved) {
        const parsed = JSON.parse(saved);
        point1 = parsed.point1;
        point2 = parsed.point2;
      }
    }

    function clearData() {
      localStorage.removeItem('rectanglePoints');
      point1 = point2 = null;
      updateStatus("üóë Data cleared");
      drawCanvas();
    }

    function setPoint(num) {
      if (!currentPos) {
        alert("Waiting for GPS...");
        return;
      }
      const point = { lat: currentPos.lat, lon: currentPos.lon };
      if (num === 1) point1 = point;
      else point2 = point;

      savePoints();
      drawCanvas();
    }

    function updateStatus(text) {
      statusEl.textContent = text;
    }

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const scale = 100000;

      if (point1 && point2) {
        const x1 = (point1.lon - baseLon()) * scale + 200;
        const y1 = (point1.lat - baseLat()) * -scale + 150;
        const x2 = (point2.lon - baseLon()) * scale + 200;
        const y2 = (point2.lat - baseLat()) * -scale + 150;

        ctx.fillStyle = "rgba(0, 200, 0, 0.2)";
        ctx.strokeStyle = "green";
        ctx.beginPath();
        ctx.rect(Math.min(x1,x2), Math.min(y1,y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
        ctx.fill();
        ctx.stroke();
      }

      if (currentPos) {
        const x = (currentPos.lon - baseLon()) * scale + 200;
        const y = (currentPos.lat - baseLat()) * -scale + 150;

        ctx.fillStyle = "blue";
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function baseLat() {
      return (point1?.lat || currentPos?.lat || 0);
    }

    function baseLon() {
      return (point1?.lon || currentPos?.lon || 0);
    }

    function isInsideRect(pos) {
      if (!point1 || !point2) return false;
      const minLat = Math.min(point1.lat, point2.lat);
      const maxLat = Math.max(point1.lat, point2.lat);
      const minLon = Math.min(point1.lon, point2.lon);
      const maxLon = Math.max(point1.lon, point2.lon);

      return (
        pos.lat >= minLat &&
        pos.lat <= maxLat &&
        pos.lon >= minLon &&
        pos.lon <= maxLon
      );
    }

    function trackLocation() {
      if (!navigator.geolocation) {
        updateStatus("Geolocation not supported.");
        return;
      }

      navigator.geolocation.watchPosition(
        (position) => {
          currentPos = {
            lat: parseFloat(position.coords.latitude.toFixed(6)),
            lon: parseFloat(position.coords.longitude.toFixed(6))
          };

          const inside = isInsideRect(currentPos);
          updateStatus(inside ? "‚úÖ Revisited" : "üÜï New Location");

          drawCanvas();
        },
        () => updateStatus("‚ùå Failed to get location"),
        {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 5000
        }
      );
    }

    loadPoints();
    trackLocation();
  </script>
</body>
</html>
